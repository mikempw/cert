import os
import json
import uuid
import shlex
import subprocess
import time
from datetime import datetime
from adapters.inventory import Inventory
from adapters.vault import Vault
from adapters.bigip import BigIP

PROVIDERS = {
    "lets-encrypt": "https://acme-v02.api.letsencrypt.org/directory",
    "google":       "https://dv.acme-v02.api.pki.goog/directory",
    "zerossl":      "https://acme.zerossl.com/v2/DV90",
    "sectigo":      "custom",
    "digicert":     "custom",
}

class Orchestrator:
    def __init__(self, inv: Inventory, vault: Vault, bigip: BigIP,
                 allow_key_export: bool = False, default_key_type: str = "EC256"):
        self.inv = inv
        self.vault = vault
        self.bigip = bigip
        self.allow_key_export = allow_key_export
        self.default_key_type = default_key_type
        self.acme_sh = "/usr/local/bin/acme.sh"
        self.work = "/work"

    def _dir_for(self, cert_id: str) -> str:
        return f"{self.work}/{cert_id}"

    # ------------------ ISSUE (with auto-publish) ------------------
    def request_certificate(self, p: dict):
        cert_id = str(uuid.uuid4())

        domains = p.get("domains") or []
        if not domains:
            raise ValueError("At least one domain is required")

        provider = p.get("provider", "lets-encrypt")
        directory = p.get("directory_url") or PROVIDERS.get(provider, "custom")
        if directory == "custom" and not p.get("directory_url"):
            raise ValueError("Custom provider requires directory_url")
        directory_url = directory if directory != "custom" else p["directory_url"]

        key_type = p.get("key_type") or self.default_key_type
        eab_secret = p.get("eab_secret")
        contact = p.get("contact_emails", [])
        tags = p.get("tags", [])
        key_secret_path = p.get("key_secret_path")
        if not key_secret_path:
            raise ValueError("key_secret_path (Vault KV v2) is required")

        bigip_host = p.get("bigip_host")
        bigip_partition = p.get("bigip_partition", "/Common")
        datagroup_name = p.get("datagroup_name", "acme_challenge_dg")

        wdir = self._dir_for(cert_id)
        os.makedirs(wdir, exist_ok=True)
        main = domains[0]

        key_type_map = {"EC256": "ec-256", "EC384": "ec-384", "RSA2048": "2048", "RSA3072": "3072", "RSA4096": "4096"}
        acme_keylen = key_type_map.get(key_type, "ec-256")

        webroot = f"{wdir}/webroot"
        os.makedirs(webroot, exist_ok=True)

        cmd_issue = [self.acme_sh, "--issue", "--server", directory_url, "--keylength", acme_keylen, "--webroot", webroot]
        for d in domains: cmd_issue += ["-d", d]
        for email in contact: cmd_issue += ["--accountemail", email]
        if eab_secret:
            eab_data = self.vault.read(eab_secret)
            kid = eab_data.get("kid"); hmk = eab_data.get("hmac_key")
            if not (kid and hmk): raise ValueError("EAB secret missing kid/hmac_key fields")
            cmd_issue += ["--eab-kid", kid, "--eab-hmac-key", hmk]

        if bigip_host:
            proc, cmd_for_log = _run_bg(cmd_issue)
            self._auto_publish_tokens_from_webroot(
                webroot=webroot,
                bigip_host=bigip_host,
                partition=bigip_partition,
                dg_name=datagroup_name,
                timeout_sec=60,
                poll_every=0.25
            )
            rc, out, err = _finish(proc)
            if rc != 0:
                raise RuntimeError(f"acme.sh cmd failed:\n{cmd_for_log}\n--- stdout ---\n{out}\n--- stderr ---\n{err}")
        else:
            _run(cmd_issue)

        cert_pem = f"{wdir}/cert.pem"
        fullchain_pem = f"{wdir}/fullchain.pem"
        key_pem = f"{wdir}/privkey.pem"
        _run([self.acme_sh, "--install-cert", "-d", main, "--key-file", key_pem, "--fullchain-file", fullchain_pem, "--cert-file", cert_pem])

        with open(key_pem, "r", encoding="utf-8") as f:
            key_text = f.read()
        self.vault.write(key_secret_path, {"private_key_pem": key_text})
        try: os.remove(key_pem)
        except Exception: pass

        not_before, not_after = _parse_dates(cert_pem)
        self.inv.create(
            cert_id=cert_id, main_domain=main, san=domains, provider=provider, directory_url=directory_url,
            not_before=not_before, not_after=not_after, path=wdir, tags=tags, status="issued", key_secret_path=key_secret_path,
        )

        challenges = _collect_http01_challenges(webroot)
        if challenges:
            self.inv.store_challenges(cert_id, [{"token": c["path"].rsplit("/",1)[-1], "keyAuthorization": c["keyAuthorization"]} for c in challenges])

        return {
            "cert_id": cert_id, "status": "issued",
            "not_before": not_before, "not_after": not_after, "san": domains,
            "challenge": {"type": "HTTP-01", "http01_files": challenges},
            "message": ("Issued with auto-publish to BIG-IP" if bigip_host else
                        "Issued via local webroot; publish tokens to BIG-IP if validating externally.")
        }

    # ------------------ FINALIZE/GET/RENEW/REVOKE/LIST ------------------
    def finalize_order(self, cert_id: str, wait_seconds: int = 60):
        rec = self.inv.get(cert_id)
        if not rec: raise ValueError("Unknown cert_id")
        if wait_seconds > 0: time.sleep(min(wait_seconds, 120))
        return {"cert_id": cert_id, "status": rec["status"], "not_before": rec["not_before"], "not_after": rec["not_after"]}

    def get_bundle(self, cert_id: str, include_key: bool = False):
        rec = self.inv.get(cert_id)
        if not rec: raise ValueError("Unknown cert_id")
        with open(f'{rec["path"]}/cert.pem', "r", encoding="utf-8") as f: cert_pem = f.read()
        with open(f'{rec["path"]}/fullchain.pem', "r", encoding="utf-8") as f: fullchain_pem = f.read()
        resp = {"cert_id": cert_id, "cert_pem": cert_pem, "chain_pem": fullchain_pem,
                "not_before": rec["not_before"], "not_after": rec["not_after"], "san": rec["san"]}
        if include_key:
            if not self.allow_key_export: raise PermissionError("Key export disabled by policy.")
            keyobj = self.vault.read(rec["key_secret_path"]); resp["private_key_pem"] = keyobj.get("private_key_pem", "")
        return resp

    def renew_certificate(self, cert_id: str):
        rec = self.inv.get(cert_id)
        if not rec: raise ValueError("Unknown cert_id")
        main = rec["main_domain"]
        _run([self.acme_sh, "--renew", "-d", main, "--force"])
        cert_pem = f'{rec["path"]}/cert.pem'; fullchain_pem = f'{rec["path"]}/fullchain.pem'
        _run([self.acme_sh, "--install-cert", "-d", main, "--key-file", f'{rec["path"]}/privkey.pem', "--fullchain-file", fullchain_pem, "--cert-file", cert_pem])
        try: os.remove(f'{rec["path"]}/privkey.pem')
        except Exception: pass
        nb, na = _parse_dates(cert_pem); self.inv.update_dates(cert_id, nb, na)
        return {"cert_id": cert_id, "status": "issued", "not_after": na}

    def revoke_certificate(self, cert_id: str, reason: str):
        rec = self.inv.get(cert_id)
        if not rec: raise ValueError("Unknown cert_id")
        _run([self.acme_sh, "--revoke", "-d", rec["main_domain"]])
        self.inv.update_status(cert_id, "revoked")
        return {"cert_id": cert_id, "status": "revoked"}

    def list_certificates(self, query: str | None, days: int, tag: str | None):
        return {"items": self.inv.search(query, days, tag)}

    # ------------------ BIG-IP publish/deploy ------------------
    def publish_http01_challenges(self, cert_id: str, challenges: list[dict],
                                  bigip_host: str, partition: str = "/Common",
                                  dg_name: str = "acme_challenge_dg"):
        if not challenges: raise ValueError("challenges array is empty")
        token_map = {}
        for ch in challenges:
            path = ch.get("path", ""); keyauth = ch.get("keyAuthorization", "")
            if path and keyauth:
                tok = path.rsplit("/", 1)[-1]; token_map[tok] = keyauth
        if not token_map: raise ValueError("No valid token/keyAuthorization pairs found in challenges")
        b = BigIP(bigip_host, self.bigip.user, self.bigip.password)
        upserted = b.upsert_http01_records(partition, dg_name, token_map)
        self.inv.store_challenges(cert_id, [{"token": t, "keyAuthorization": v} for t, v in token_map.items()])
        return {"cert_id": cert_id, "bigip": bigip_host, "partition": partition, "datagroup": dg_name, "upserted": upserted}

    def deploy_to_bigip(self, cert_id: str, host: str, partition: str,
                        clientssl: str | None, sni_name: str | None,
                        create_profile: bool = True, virtual_server: str | None = None):
        rec = self.inv.get(cert_id)
        if not rec: raise ValueError("Unknown cert_id")

        with open(f'{rec["path"]}/cert.pem', "r", encoding="utf-8") as f: cert_pem = f.read()
        with open(f'{rec["path"]}/fullchain.pem', "r", encoding="utf-8") as f: full_pem = f.read()
        keyobj = self.vault.read(rec["key_secret_path"]); key_pem = keyobj.get("private_key_pem")
        if not key_pem: raise ValueError(f"Private key not found in Vault at {rec['key_secret_path']}")

        b = BigIP(host, self.bigip.user, self.bigip.password)

        namesafe = rec["main_domain"].replace("*", "wildcard").replace(".", "_")
        base = f"{namesafe}_{cert_id[:8]}"
        keyname, certname, chainname = f"{base}.key", f"{base}.crt", f"{base}_chain.crt"

        b.upload_and_install(partition, keyname, key_pem, certname, cert_pem, chainname, full_pem)

        if not clientssl:
            clientssl = f"clientssl_{namesafe}"

        prof_full = f"/{partition.strip('/')}/{clientssl}"
        if create_profile:
            prof_full = b.ensure_clientssl_profile(partition, clientssl, defaults_from="/Common/clientssl")

        b.attach_to_clientssl(partition, clientssl, keyname, certname, chainname, sni_name)

        if virtual_server:
            b.attach_profile_to_virtual(virtual_server, prof_full)

        self.inv.mark_deployed(cert_id, host, partition, clientssl, sni_name)
        return {"cert_id": cert_id, "bigip": host, "profile": prof_full, "sni": sni_name, "attached_to_vs": virtual_server or None}

    # ------------------ internals ------------------
    def _auto_publish_tokens_from_webroot(self, webroot: str, bigip_host: str,
                                          partition: str, dg_name: str,
                                          timeout_sec: int = 30, poll_every: float = 0.25) -> int:
        seen = set(); start = time.time(); published_total = 0
        b = BigIP(bigip_host, self.bigip.user, self.bigip.password)
        path = os.path.join(webroot, ".well-known", "acme-challenge")
        os.makedirs(path, exist_ok=True)
        while time.time() - start < timeout_sec:
            try: files = [f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))]
            except FileNotFoundError: files = []
            new_tokens = [f for f in files if f not in seen]
            if new_tokens:
                token_map = {}
                for tok in new_tokens:
                    with open(os.path.join(path, tok), "r", encoding="utf-8") as fh:
                        ka = fh.read().strip()
                    token_map[tok] = ka
                if token_map:
                    b.upsert_http01_records(partition, dg_name, token_map)
                    published_total += len(token_map)
                seen.update(new_tokens)
                time.sleep(1.0)
            time.sleep(poll_every)
        return published_total

# ------------------ subprocess helpers ------------------
def _run(args):
    if isinstance(args, list):
        p = subprocess.run(args, capture_output=True, text=True, shell=False)
        cmd_for_log = " ".join(shlex.quote(a) for a in args)
    else:
        p = subprocess.run(args, capture_output=True, text=True, shell=True)
        cmd_for_log = args
    if p.returncode != 0:
        raise RuntimeError(f"acme.sh cmd failed:\n{cmd_for_log}\n--- stdout ---\n{p.stdout}\n--- stderr ---\n{p.stderr}")
    return p.stdout

def _run_bg(args):
    if not isinstance(args, list): raise ValueError("Background run requires argv list")
    proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    cmd_for_log = " ".join(shlex.quote(a) for a in args)
    return proc, cmd_for_log

def _finish(proc: subprocess.Popen):
    out, err = proc.communicate()
    return proc.returncode, out or "", err or ""

# ------------------ misc helpers ------------------
def _parse_dates(cert_path: str):
    out = _run(['openssl', 'x509', '-in', cert_path, '-noout', '-dates'])
    nb, na = None, None
    for line in out.splitlines():
        if line.startswith("notBefore="): nb = _to_iso(line.split("=", 1)[1].strip())
        if line.startswith("notAfter="):  na = _to_iso(line.split("=", 1)[1].strip())
    return nb, na

def _to_iso(openssl_dt: str):
    return datetime.strptime(openssl_dt, "%b %d %H:%M:%S %Y %Z").isoformat() + "Z"

def _collect_http01_challenges(webroot: str):
    root = os.path.join(webroot, ".well-known", "acme-challenge")
    results = []
    if not os.path.isdir(root): return results
    for f in os.listdir(root):
        p = os.path.join(root, f)
        if os.path.isfile(p):
            try:
                content = open(p, "r", encoding="utf-8").read().strip()
                results.append({"path": f"/.well-known/acme-challenge/{f}", "keyAuthorization": content})
            except Exception:
                pass
    return results
